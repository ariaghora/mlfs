[
  {
    "objectID": "ndarray.html",
    "href": "ndarray.html",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "",
    "text": "Struktur data n-dimensional array (selanjutnya disebut “ndarray”), atau yang oleh beberapa framework deep learning disebut tensor, adalah tulang punggung teknologi machine learning. Struktur data ini seringkali taken for granted: kita bisa memakainya, namun tidak terlalu tahu mekanisme internalnya.\n\n\n\n\n\n\nCatatan\n\n\n\nPenulis sengaja menghindari penggunaan istilah “tensor”, karena di disiplin ilmu matematika murni tensor memiliki arti yang berbeda. Walau tensor bisa direpresentasikan dengan ndarray, ia memiliki karakteristik lain, lebih dari sekadar ndarray, atau “matriks dengan dimensi lebih dari dua”.\n\n\nNumpy (Harris et al. 2020) sendiri mendefinisikan ndarray sebagai array yang merepresentasikan elemen-elemen dalam multidimensi, di mana jumlah elemen pada masing-masing dimensi berjumlah seragam. Ini mirip seperti nested array, yaitu array dalam array (dalam array (dalam array (…))). Beberapa perkakas machine learning dan deep learning menyebutnya sebagai tensor. Semuanya sama-sama mengacu pada bentuk umum dari skalar, vektor, dan matriks. Jika skalar memiliki 0 dimensi, vektor memiliki 1 dimensi dan matriks memiliki 2 dimensi, maka ndarray bisa saja memiliki sembarang dimensi, N, dengan N\\geq 0. Bisa 3 dimensi, 4 dimensi, dst.\nDi library ndarray modern (NumPy ndarray (Harris et al. 2020), tensorflow tensor (Abadi et al. 2015), atau PyTorch tensor (Paszke et al. 2019)), jumlah dimensi, urutan dimensi, elemen data, dan aspek lain suatu ndarray harus dapat dimanipulasi saat run-time. Ini berbeda dengan nested array yang dimensinya sudah harus ditetapkan saat deklarasi/inisialisasi dan tidak bisa diubah lagi saat run-time. Misalnya, pada c/c++ kita bisa membuat array 2 dimensi:\nint[3][3] x;    \nNamun, hingga akhir program, x tetap 2 dimensi. Tidak berubah, dan tidak bisa diubah.\nNdarray array adalah komponen penting dalam perkembangan teknologi machine learning hingga deep learning. Biasanya ia digunakan untuk merepresentasikan data. Misal, data tabel dapat direpresentasikan dengan ndarray 2 dimensi berbentuk N_{baris} \\times N_{kolom}. Data citra dapat direpresentasikan dengan ndarray 4 dimensi berbentuk N_{sampel} \\times N_{panjang} \\times N_{lebar} \\times N_{channel}."
  },
  {
    "objectID": "ndarray.html#shape",
    "href": "ndarray.html#shape",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Shape",
    "text": "Shape\nShape, seperti namanya, ia menentukan bentuk suatu ndarray. Shape dapat direpresentasikan sebagai tuple. Contoh: shape dari ndarray 2 dimensi (matriks) berbentuk 2 \\times 2 direpresentasikan dengan (2,2). Secara formal, ndarray berdimensi N memiliki shape berupa \\mathbf{d}=(d_0, d_1, ..., d_{N-1})."
  },
  {
    "objectID": "ndarray.html#strides",
    "href": "ndarray.html#strides",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Strides",
    "text": "Strides\nJumlah langkah yang dibutuhkan untuk menuju dimensi selanjutnya. Array pada ilustrasi di atas memiliki strides (3, 1). Artinya, untuk menuju ke elemen selanjutnya di dimensi ke-2 (kolom), cukup lompat 1 saja. Namun, di dimensi pertama (baris), kita harus melompati 3 elemen untuk menuju kolom yang sama namun di baris selanjutnya.\nJumlah elemen pada strides selalu sama dengan jumlah elemen pada shape. Strides direpresentasikan sebagai tuple juga: \\mathbf{s}=(s_0, s_1, ..., s_{N-1}). Kita bisa menghitung masing-masing elemen di strides, s_i, berdasarkan shape dengan persamaan 1.\n\n    s_i = \\prod_{j+i+1}^{N-1} d_j\n\\tag{1}"
  },
  {
    "objectID": "ndarray.html#mengakses-elemen-ndarray",
    "href": "ndarray.html#mengakses-elemen-ndarray",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Mengakses elemen ndarray",
    "text": "Mengakses elemen ndarray\nPosisi (secara fisik) dari elemen pada data ndarray di memori kita sebut offset. Elemen pertama dari data tersebut bisa diakses pada offset 0. Bagaimana jika kita ingin memperoleh offset berdasarkan index? Misal, kita mempunyai ndarray berbentuk (3, 3). Maka strides-nya adalah (3, 1) Jika kita ingin menghitung offset dengan index (n_0, n_1), di mana n_0 adalah index baris dan n_1 adalah index kolom, maka kalkulasinya adalah\n\noffset = n_0 \\times s_0 + n_1 \\times s_1.\n\\tag{2}\nSama halnya dengan mengakses ndarray 3 dimensi dengan index (n_0, n_1, n_2), dengan n_2 sebagai dimensi kedalaman. Pertama, peroleh strides-nya, kemudian hitung offset-nya dengan cara\n\noffset = n_0 \\times s_0 + n_1 \\times s_1 + n_2 \\times s_2.\n\\tag{3}\nIstilah teknis dari index (n_0, n_1, ..., n_{N-1}) pada ndarray berdimensi N adalah multidimensional index. Secara umum, berdasarkan suatu multidimensional index (n_0, n_1, ..., n_{N-1}), offset dapat kita hitung dengan persamaan 4.\n\n    offset = \\sum_{i=0}^{N-1} s_i n_i\n\\tag{4}"
  },
  {
    "objectID": "ndarray.html#sketsa-awal-ndarray",
    "href": "ndarray.html#sketsa-awal-ndarray",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Sketsa awal ndarray",
    "text": "Sketsa awal ndarray\nKita mulai dengan sebuah kelas NDArray, yaitu kelas utama untuk struktur data ndarray, dengan 3 properties utama: data, shape, dan strides. Selain itu, sertakan juga fungsi untuk membuat ndarray dari python list, ndrray_from_list(). Di fungsi ndarray_from_list(), argumen untuk parameter lst akan menjadi data bagi ndarray baru. Property shape akan mengikuti argument untuk parameter shape, dan kita cast menjadi list (untuk konsistensi).\nimport math\n\nclass NDArray:\n    def __init__(self):\n        self.data = None\n        self.shape = None\n        self.strides = None\n\n\ndef ndarray_from_list(lst, *shape):\n    if len(lst) != math.prod(shape):\n        raise Exception(\n            f\"List dengan panjang {len(lst)} tidak bisa dijadikan ndarray berbentuk {shape}\"\n        )\n    x = NDArray()\n    x.data = lst\n    x.shape = list(shape)\n    x.strides = shape_to_strides(shape)\n    return x    \nSaat inisialisasi ndarray, strides akan dihitung secara otomatis berdasarkan shape. Di bawah ini adalah implementasi dari fungsi shape_to_stride().\n...\n\ndef shape_to_strides(shape):\n    strides = []\n    for i in range(len(shape)):\n        prod = 1\n        for j in range(i + 1, len(shape)):\n            prod *= shape[j]\n        strides.append(prod)\n    return strides\nFungsi ini berdasarkan persamaan 1. Di tahap ini kita bisa mencoba menggunakan ndarray. Misalnya:\n\nx = ndarray_from_list([1, 2, 3, 4], 2, 2)\nprint(x.data)\nprint(x.shape)\nprint(x.strides)\n\n[1, 2, 3, 4]\n[2, 2]\n[2, 1]\n\n\nKode di atas menghasilkan objek ndarray dengan data berisi [1, 2, 3, 4] dan shape dengan nilai (2, 2) (ekuivalen dengan matriks 2 \\times 2).\nBagian actual_data adalah data dalam urutan sebenarnya pada memori. Bagian intended_data adalah data dalam urutan dengan versi yang dilihat oleh kita (user). Di contoh ini, keduanya masih sama, karena belum ada manipulasi apapun terhadap ndarray ini.\nSelanjutnya, kita akan mengimplementasikan akses ke elemen pada ndarray dengan indeks tertentu (misal, berdasarkan baris i, kolom j). Tambah method get_item() pada kelas NDArray.\nclass NDArray:\n    def __init__(self):\n        self.data = None\n        self.shape = None\n        self.strides = None\n    \n    def get_item(self, *index):\n        actual_offset = sum(i * s for i, s in zip(index, self.strides))\n        return self.data[actual_offset] \nFungsi ini menerima input multidimensional index dari elemen yang akan kita akses, kemudian mengonversi index tersebut menjadi offset. Contoh:\nx = ndarray_from_list([1, 2, 3, 4], 2, 2)\n\n# dengan multidimensional index, kita bisa mengakses elemen 3 \n# sebagai berikut, karena 3 berada di baris 1, kolom 0\nitem = x.get_item(1, 0)\nMethod get_item akan mengonversi multidimensional index (1,0) menjadi offset (yaitu 2), kemudian mengakses elemen ke-2 pada x.data. Perhatikan bahwa actual_offset diperoleh berdasarkan persamaan 4. Kita juga bisa melakukan indexing pada ndarray dengan dimensi lebih tinggi, misalnya ndarray 3 dimensi, dengan cara yang sama:\n\n# Buat ndarray berbentuk 2x2x2\nx = ndarray_from_list([1, 2, 3, 4, 5, 6, 7, 8], 2, 2, 2)\n\n# koordinat ini mengacu ke elemen angka 6\nitem = x.get_item(1, 0, 1)  \nprint(\"Item pada koordinat (1,0,1):\", item)\n\nItem pada koordinat (1,0,1): 6\n\n\nSeringkali kita akan membutuhkan akses data ndarray sebagai python list (flat/1-d list). Caranya adalah menampung semua elemen ndarray dari offset 0 hingga akhir. Pertama, implementasi method get_size() untuk membantu menghitung ukuran (atau panjang data seharusnya) dari data ndarray. Sederhana saja, ukuran ndarray merupakan hasil perkalian dari elemen pada shape. Sebagai contoh, ndarray 2 dimensi (matriks) berbentuk (3, 2) akan memiliki ukuran 3 \\times 2 = 6. Kedua, implementasi fungsi offset_to_index() untuk mengonversi balik offset ke list berisi multidimensional index.\nclass NDArray:\n    def __init__(self):\n        self.data = None\n        self.shape = None\n        self.strides = None\n    \n    def get_item(self, *index):\n        actual_offset = sum(i * s for i, s in zip(index, self.strides))\n        return self.data[actual_offset] \n\n    def get_size(self):\n        return math.prod(self.shape)\n\n    def as_list(self):\n        result = []\n        for i in range(self.get_size()):\n            index = offset_to_index(self, i)\n            value = self.get_item(*index)\n            result.append(value)\n        return result\n\n...\n\n\ndef offset_to_index(arr, offset):\n    index = [None for i in range(len(arr.shape))]\n    tmp_offset = offset\n    for i in reversed(range(len(arr.shape))):\n        index[i] = int(tmp_offset % arr.shape[i])\n        tmp_offset /= arr.shape[i]\n    return index\nPertanyaan yang mungkin muncul namun akan terjawab nanti: “mengapa untuk mencari ukuran ndarray tidak menggunakan len(self.data) saja?”\nSampai saat ini, kita masih belum akan mencetak ndarray sekarang, karena untuk dapat mencetak dengan benar (data berikut juga bentuknya), kita membutuhkan kalkulasi lebih lanjut. Namun, sementara ini kita akan menggunakan cara “curang” agar bisa mencetak ndarray dengan bentuk yang sesuai dengan memanfaatkan NumPy. Nanti kita akan ganti dengan implementasi kita sendiri.\nImplementasikan 2 fungsi berikut ini. Yang pertama untuk mencetak dengan format tertentu (pretty print), yang kedua untuk mencetak atribut ndarray untuk mempermudah proses debugging.\nimport pprint\nimport numpy as np\n\n...\n\ndef print_ndarray(arr):\n    # Walau menggunakan numpy, data dan shape tetap berdasarkan \n    # implementasi kita sendiri\n    x = np.array([float(i) for i in arr.as_list()]).reshape(*arr.shape)\n    print(x.__repr__())\n\n\ndef debug_print(arr):\n    info = dict(\n        actual_data=arr.data,\n        intended_data=arr.as_list(),\n        shape=arr.shape,\n        strides=arr.strides,\n    )\n    pprint.pprint(info)\nKita dapat menggunakannya sebagai berikut.\n\nx = ndarray_from_list([1, 2, 3, 4], 2, 2)\n\nprint(\"Array:\")\nprint_ndarray(x)\n\nprint()\n\nprint(\"Debug info:\")\ndebug_print(x)  \n\nArray:\narray([[1., 2.],\n       [3., 4.]])\n\nDebug info:\n{'actual_data': [1, 2, 3, 4],\n 'intended_data': [1, 2, 3, 4],\n 'shape': [2, 2],\n 'strides': [2, 1]}"
  },
  {
    "objectID": "ndarray.html#contoh-kegunaan-manipulasi-stride",
    "href": "ndarray.html#contoh-kegunaan-manipulasi-stride",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Contoh kegunaan manipulasi stride",
    "text": "Contoh kegunaan manipulasi stride\nSampai di titik ini, kita akan mulai bisa melihat “keajaiban” trik manipulasi strides dan shape. Ini juga alasan mengapa NumPy bisa sangat efisien.\n\nTransposisi\nSaat melakukan transposisi pada suatu ndarray x, berarti kita melakukan pertukaran antara elemen baris dan kolom dari x. Ini bisa saja kita lakukan dengan melakukan iterasi atas baris dan kolom, kemudian menukar x[i][j] dengan x[j][i].\nNamun, sebetulnya kita tidak perlu melakukan iterasi yang mahal itu. Triknya adalah, kita cukup membalik x.shape dan x.strides. Misal, ndarray berbentuk (3, 2) dapat ditransposisi menjadi berbentuk (2, 3) dengan elemen baris dan kolom yang ditukar, seperti ini:\n\n### ndarray mula-mula\nx = ndarray_from_list([1, 2, 3, 4, 5, 6], 3, 2)\n\nprint(\"Sebelum transposisi:\")\nprint(\"Array:\")\nprint_ndarray(x)\nprint()\nprint(\"Debug info:\")\ndebug_print(x)\n\n\n### Dua baris di bawah ini adalah trik transposisi kita\nx.shape = list(reversed(x.shape))\nx.strides = list(reversed(x.strides))\n\nprint()\nprint(\"Setelah transposisi:\")\nprint(\"Array:\")\nprint_ndarray(x)\nprint()\nprint(\"Debug info:\")\ndebug_print(x)\n\nSebelum transposisi:\nArray:\narray([[1., 2.],\n       [3., 4.],\n       [5., 6.]])\n\nDebug info:\n{'actual_data': [1, 2, 3, 4, 5, 6],\n 'intended_data': [1, 2, 3, 4, 5, 6],\n 'shape': [3, 2],\n 'strides': [2, 1]}\n\nSetelah transposisi:\nArray:\narray([[1., 3., 5.],\n       [2., 4., 6.]])\n\nDebug info:\n{'actual_data': [1, 2, 3, 4, 5, 6],\n 'intended_data': [1, 3, 5, 2, 4, 6],\n 'shape': [2, 3],\n 'strides': [1, 2]}\n\n\nSetelah transposisi, actual_data berbeda dengan intended_data karena strides dan shape, yang menentukan urutan iterasi per-elemen, telah berubah (dimanipulasi). Ternyata kita sama sekali tidak perlu mengubah urutan data sebenarnya di memori saat melakukan transposisi. Yang perlu dilakukan adalah memanipulasi cara kita (user) dalam melihat urutan; dan cara yang bisa dilakukan untuk memanipulasi user dalam melihat urutan adalah dengan memanipulasi shape dan strides. Jadi, jika ada ndarray berbentuk (1000000, 1000000), kita tidak perlu melakukan iterasi sebanyak ratusan ribu kali untuk dalam melakukan transposisi. Cukup mainkan saja shape dan stride-nya.\n\n\nBroadcasting\nBanyak pustaka ndarray modern mengadopsi mekanisme broadcasting. Perhatikan contoh pada Gambar 3.\n\n\n\nGambar 3: Ilustrasi broadcasting\n\n\nSaat melakukan operasi aritmatika antara kedua ndarray dengan bentuk berbeda, ndarray yang lebih kecil seolah-olah diduplikat hingga kedua ndarray memiliki jumlah baris yang sama. Mekanisme ini disebut broadasting: salah satu atau kedua ndarray dengan ukuran berbeda di-broadcast satu sama lain, sehingga keduanya memiliki bentuk yang kompatibel (selama memenuhi syarat tertentu). Dengan trik stride, kita tidak perlu membuat duplikat yang tidak perlu di memori:\n\nB = ndarray_from_list([5, 5, 5], 3)\n\nprint(\"Mula-mula:\")\nprint_ndarray(B)\ndebug_print(B)\n\n# Dua baris berikut ini adalah proses broadcasting\n# ndarray ukuran (3,) menjadi (3, 3)\nB.shape = [3] + B.shape  # Prepend menambah dimensi berukuran 3 di depan\nB.strides = [0] + B.strides  # Pepend stride untuk dimensi yang baru dengan 0\n\nprint()\nprint(\"Setelah broadcasting:\")\nprint_ndarray(B)\ndebug_print(B)\n\nMula-mula:\narray([5., 5., 5.])\n{'actual_data': [5, 5, 5],\n 'intended_data': [5, 5, 5],\n 'shape': [3],\n 'strides': [1]}\n\nSetelah broadcasting:\narray([[5., 5., 5.],\n       [5., 5., 5.],\n       [5., 5., 5.]])\n{'actual_data': [5, 5, 5],\n 'intended_data': [5, 5, 5, 5, 5, 5, 5, 5, 5],\n 'shape': [3, 3],\n 'strides': [0, 1]}\n\n\nLagi-lagi, yang berubah hanya shape dan strides, dan data di memori tidak berubah sama sekali. Dengan shape dan strides yang demikian, persepsi user akan dihadapkan dengan data ndarray yang (secara linear) tersusun seperti pada intended_data.\nIni juga menjawab pertanyaan mengapa kita tidak menggunakan len(self.data) di method get_size() untuk memperoleh ukuran ndarray. Untuk contoh di atas, ekspresi len(self.data) akan menghasilkan nilai 3, sementara yang kita harapkan adalah 9 (karena broadcasting). Maka, prod(self.shape) lebih tepat, karena ukuran ndarray selalu bergantung pada bentuknya."
  },
  {
    "objectID": "ndarray.html#pembaharuan-kelas-ndarray",
    "href": "ndarray.html#pembaharuan-kelas-ndarray",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Pembaharuan kelas NDArray",
    "text": "Pembaharuan kelas NDArray\nTambah properti indices dan implementasikan method rebuild_index(). Perbarui juga fungsi ndarray_from_list dengan menambahkan x.rebuild_index().\nclass NDArray:\n    def __init__(self):\n        self.data = None\n        self.shape = None\n        self.strides = None\n        self.indices = None  # properti baru\n    \n    def get_item(self, *index):\n        actual_offset = sum(i * s for i, s in zip(index, self.strides))\n        return self.data[actual_offset] \n\n    def get_size(self):\n        return math.prod(self.shape)\n\n    def as_list(self):\n        result = []\n        for i in range(self.get_size()):\n            index = offset_to_index(self, i)\n            value = self.get_item(*index)\n            result.append(value)\n        return result\n    \n    def rebuild_index(self):  # method baru\n        indices = []\n        for s in self.shape:\n            indices.append(list(range(s)))\n        self.indices = indices\n        \n\n...\n\n\ndef ndarray_from_list(lst, *shape):\n    if len(lst) != math.prod(shape):\n        raise Exception(\n            f\"List dengan panjang {len(lst)} tidak bisa dijadikan ndarray berukuran {shape}\"\n        )\n    x = NDArray()\n    x.data = lst\n    x.shape = list(shape)\n    x.strides = shape_to_strides(shape)\n    x.rebuild_index()  # tambahkan baris ini\n    return x\nMethod rebuild_index() bertujuan untuk menginisialisasi indeks pada masing-masing dimensi dengan list berisi 0, 1, ..., d_i, di mana d_i adalah panjang dimensi ke-i. Indeks-indeks ini akan berguna seperti strides, yang memungkinkan kita melakukan trik penyeleksian elemen-elemen pada ndarray.\nSekarang kita sudah memiliki informasi indeks pada masing-masing dimensi, sehingga fungsi offset_to_index perlu diperbarui.\ndef offset_to_index(arr, offset):\n    index = [None for _ in range(len(arr.shape))]\n    tmp_offset = offset\n    for i in reversed(range(len(arr.shape))):\n        index[i] = arr.indices[i][int(tmp_offset % arr.shape[i])]\n        tmp_offset /= arr.shape[i]\n    return index"
  },
  {
    "objectID": "ndarray.html#implementasi-indexing",
    "href": "ndarray.html#implementasi-indexing",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Implementasi indexing",
    "text": "Implementasi indexing\nAgar bisa menggunakan operator indeks [ ] pada ndarray x (misal, x[...]), kita perlu melakukan override dunder method __getitem__().\n...\nfrom collections.abc import Iterable  # import baru\n\nclass NDArray:\n    def __init__(self):\n        self.data = None\n        self.shape = None\n        self.strides = None\n        self.indices = None  \n    \n    def get_item(self, *index):\n        actual_offset = sum(i * s for i, s in zip(index, self.strides))\n        return self.data[actual_offset] \n\n    def get_size(self):\n        return math.prod(self.shape)\n\n    def as_list(self):\n        result = []\n        for i in range(self.get_size()):\n            index = offset_to_index(self, i)\n            value = self.get_item(*index)\n            result.append(value)\n        return result\n    \n    def rebuild_index(self):  \n        indices = []\n        for s in self.shape:\n            indices.append(list(range(s)))\n        self.indices = indices\n\n    def __getitem__(self, indices):  # method baru\n        # Memastikan agar indices berupa iterable\n        indices = (indices,) if not isinstance(indices, Iterable) else indices\n        new_indices = []\n        for i, index in enumerate(indices):\n            if isinstance(index, int):\n                new_indices.append([index])\n            elif isinstance(index, slice):\n                start = 0 if index.start is None else index.start\n                step = 1 if index.step is None else index.step\n                stop = self.shape[i] if index.stop is None else index.stop\n                index = list(range(start, stop, step))\n                new_indices.append(index)\n            else:\n                try:\n                    index = [i for i in index]\n                    new_indices.append(index)\n                except:\n                    raise Exception(f\"Indeks tidak valid: {index}\")\n\n        if len(self.shape) > len(indices):\n            new_indices.append(*self.indices[len(indices) :])\n\n        new_shape = [len(index) for index in new_indices]\n        x = NDArray()\n        x.data = self.data\n        x.strides = self.strides\n        x.shape = new_shape\n        x.indices = new_indices\n        return x\nDi tahap ini kita sudah bisa melakukan indexing, seperti contoh-contoh berikut ini:\n\n# Buat ndarray dengan bentuk (3, 3)\nx = ndarray_from_list(\n    [1, 2, 3, \n     4, 5, 6, \n     7, 8, 9], \n     \n     3, 3\n)\n\nprint_ndarray(x[0])\nprint_ndarray(x[:, 1])\n\narray([[1., 2., 3.]])\narray([[2.],\n       [5.],\n       [8.]])"
  },
  {
    "objectID": "ndarray.html#fungsi-unary",
    "href": "ndarray.html#fungsi-unary",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Fungsi unary",
    "text": "Fungsi unary\nFungsi unary adalah fungsi yang memiliki 1 parameter. Sebagai contoh, \\sin(x), \\log(x), \\exp(x) adalah contoh fungsi unary. Operasi aritmatik negatif -x juga bisa diekspresikan sebagai fungsi unary, misalnya neg(x). Di implementasi kita, fungsi unary diaplikasikan pada masing-masing elemen pada ndarray. Implementasi dari bentuk umum fungsi unary dapat dilakukan sebagai berikut.\n...\n\ndef ufunc(arr, func):\n    new_data = []\n    for val in arr.data:\n        new_data.append(func(val))\n\n    x = NDArray()\n    x.data = new_data\n    x.shape = arr.shape\n    x.strides = arr.strides\n    x.indices = arr.indices\n    return x\nPada dasarnya, fungsi ini menerima argumen berupa ndarray dan fungsi unary apa yang akan diaplikasikan. Fungsi ufunc() akan melakukan iterasi satu-persatu pada elemen ndarray kemudian memanggil func(x) dan menyimpan hasilnya di new_data. Variabel new_data ini yang kemudian menjadi data baru bagi ndarray kembalian fungsi ufunc(). Kita dapat menurunkan fungsi unary yang lebih spesifik lagi.\nimport math\n\n...\n\ndef exp(arr):\n    # kita bisa menggunakan mem-pass lambda function\n    return ufunc(arr, lambda x: math.exp(x))\n\n\ndef sin(arr):\n    # kita juga bisa langsung mem-pass fungsi dari module math\n    return ufunc(arr, math.sin)\nBerikut ini adalah contoh penggunaan dari kedua fungsi di atas:\n\nx = ndarray_from_list([math.radians(x) for x in [0, 30, 90]], 3, 1)\n\nprint_ndarray(sin(x))\nprint()\nprint_ndarray(exp(x))\n\narray([[0. ],\n       [0.5],\n       [1. ]])\n\narray([[1.        ],\n       [1.68809179],\n       [4.81047738]])"
  },
  {
    "objectID": "ndarray.html#fungsi-binary",
    "href": "ndarray.html#fungsi-binary",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Fungsi binary",
    "text": "Fungsi binary\nJika fungsi unary memiliki satu parameter, fungsi binary memiliki dua parameter. Banyak operasi aritmatika yang dapat direpresentasikan oleh fungsi binary, seperti penjumlahan, perkalian, pengurangan, dan sebagainya. Fungsi binary sebagai fungsi penjumlahan dua ndarray akan bekerja selayaknya penjumlahan masing-masing elemen pada kedua ndarray tersebut. Karena itulah, bentuk dari kedua ndarray harus kompatibel. Jika salah satu atau kedua ndarray yang akan kita masukkan dalam fungsi binary memiliki bentuk berbeda, maka kita perlu melakukan broadcasting.\n\nBroadcasting\nDi bagian awal kita sudah menyinggung sedikit tentang broadcasting, proses penyesuaian bentuk dua ndarray sehingga keduanya memiliki bentuk yang kompatibel. Broadcasting diperlukan saat kita akan melakukan fungsi binary, karena kita perlu menerapkan fungsi per-elemen, dan masing-masing elemen di ndarray pertama berkorespondensi satu-satu dengan elemen di ndarray kedua (dengan koordinat yang sama).\nBroadacsting bisa berarti menyesuaikan bentuk ndarray yang lebih “kecil” agar kompatibel dengan yang lebih besar (Gambar 3). Namun, broadcasting juga bisa berarti kedua ndarray saling menyesuaikan satu sama lain hingga kompatibel. Ini seperti ditunjukkan pada Gambar 6.\n\n\n\nGambar 6: Ilustrasi broadcasting di mana kedua ndarray di-broadcast satu sama lain\n\n\nBroadcasting memiliki aturan khusus. Kita akan mengadopsi aturan dari NumPy. Misal, d^A_i adalah elemen shape ndarray A pada dimensi ke-i, dan d^B_i adalah elemen shape ndarray B pada dimensi ke-i. Misalkan juga, N_A dan N_B adalah jumlah dimensi dari ndarray A dan B. Maka:\n\nAturan 1: Jika dua ndarray memiliki jumlah dimensi berbeda (N_A \\neq N_B), maka shape dari ndarray yang lebih sedikit dimensinya dibubuhkan dengan angka 1 (dari kiri), hingga N_A = N_B.\nAturan 2: Jika d^A_i \\neq d^B_i pada dimensi ke-i, maka:\n\njika d^A_i = 1, maka ubah sedemikian hingga d^A_i=d^B_i.\nBegitu juga, jika d^B_i = 1, maka ubah sedemikian hingga d^B_i=d^A_i.\n\nAturan 3: Jika elemen shape kedua ndarray tidak sama untuk semua dimensi; atau jika tidak sama dengan 1, maka broadcasting tidak dapat dilakukan. Munculkan pesan error.\n\n...\n\ndef broadcast(arr1, arr2):\n    # Kedua ndarray berukuran sama, tidak ada yang perlu dilakukan, dan\n    # langsung kembali\n    if arr1.shape == arr2.shape:\n        return arr1, arr2\n\n    # Jumlah dimensi baru yang akan menjadi target\n    new_ndims = max(len(arr1.shape), len(arr2.shape))\n\n    # Aturan 1\n    new_shape_1 = [1 for _ in range(new_ndims - len(arr1.shape))] + arr1.shape\n    new_shape_2 = [1 for _ in range(new_ndims - len(arr2.shape))] + arr2.shape\n    # Karena melibatkan strides, maka harus kita sesuaikan juga. Strides pada dimensi\n    # yang di-expand, perlu di-set menjadi 0\n    new_strides_1 = [0 for _ in range(new_ndims - len(arr1.strides))] + arr1.strides\n    new_strides_2 = [0 for _ in range(new_ndims - len(arr2.strides))] + arr2.strides\n\n    for i in range(new_ndims):\n        # Aturan 2\n        if new_shape_1[i] != new_shape_2[i]:\n            if new_shape_1[i] < new_shape_2[i] and new_shape_1[i] <= 1:\n                new_strides_1[i] = 0\n                new_shape_1[i] = new_shape_2[i]\n            elif new_shape_2[i] < new_shape_1[i] and new_shape_2[i] <= 1:\n                new_strides_2[i] = 0\n                new_shape_2[i] = new_shape_1[i]\n            else:\n                # Aturan 3\n                raise Exception(\n                    \"Tidak bisa melakukan broadcasting pada array dengan bentuk {arr1.shape} dan {arr2.shape}\"\n                )\n    new_arr1 = NDArray()\n    new_arr1.data = arr1.data\n    new_arr1.shape = new_shape_1\n    new_arr1.strides = new_strides_1\n    new_arr1.rebuild_index()\n\n    new_arr2 = NDArray()\n    new_arr2.data = arr2.data\n    new_arr2.shape = new_shape_2\n    new_arr2.strides = new_strides_2\n    new_arr2.rebuild_index()\n\n    return new_arr1, new_arr2\n\n\nBroadcasting untuk fungsi binary\nDengan diimplementasikannya fungsi broadcasting, implementasi fungsi binary akan menjadi mudah. Katakanlah, kita ingin mengimplementasikan fungsi add, subtract, multiply, dan divide. Yang perlu dilakukan mirip seperti apa yang kita lakukan dengan fungsi unary:\n...\n\ndef bfunc(arr1, arr2, func):\n    # Pertama, pastikan shape arr1 dan arr2 kompatibel\n    arr1, arr2 = broadcast(arr1, arr2)\n    \n    data1 = arr1.as_list()\n    data2 = arr2.as_list()\n\n    new_data = []\n    for x, y in zip(data1, data2):\n        new_data.append(func(x, y))\n\n    return ndarray_from_list(new_data, *arr1.shape)\n    \n\ndef add(arr1, arr2):\n    return bfunc(arr1, arr2, lambda x, y: x + y)\n\n\ndef subtract(arr1, arr2):\n    return bfunc(arr1, arr2, lambda x, y: x - y)\n\n\ndef multiply(arr1, arr2):\n    return bfunc(arr1, arr2, lambda x, y: x * y)\n\n\ndef divide(arr1, arr2):\n    return bfunc(arr1, arr2, lambda x, y: x / y)"
  },
  {
    "objectID": "ndarray.html#operator-overloading",
    "href": "ndarray.html#operator-overloading",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Operator overloading",
    "text": "Operator overloading\nKita bisa melakukan operator overloading sehingga kita bisa melakukan penjumlahan ndarray x dan y dengan cara menuliskan x + y, tanpa harus memanggil fungsi add(x, y). Operator overloading dapat dilakukan dengan cara melakukan override pada dunder method yang relevan. Misal, untuk penjumlahan:\nclass NDArray:\n    def __init__(self):\n        self.data = None\n        self.shape = None\n        self.strides = None\n        self.indices = None  \n    \n    def get_item(self, *index):\n        actual_offset = sum(i * s for i, s in zip(index, self.strides))\n        return self.data[actual_offset] \n\n    def get_size(self):\n        return math.prod(self.shape)\n\n    def as_list(self):\n        result = []\n        for i in range(self.get_size()):\n            index = offset_to_index(self, i)\n            value = self.get_item(*index)\n            result.append(value)\n        return result\n    \n    def rebuild_index(self):  \n        indices = []\n        for s in self.shape:\n            indices.append(list(range(s)))\n        self.indices = indices\n\n    def __getitem__(self, indices):  \n        # Memastikan agar indices berupa iterable\n        indices = (indices,) if not isinstance(indices, tuple) else indices\n        new_indices = []\n        for i, index in enumerate(indices):\n            if isinstance(index, int):\n                new_indices.append([index])\n            elif isinstance(index, slice):\n                start = 0 if index.start is None else index.start\n                step = 1 if index.step is None else index.step\n                stop = self.shape[i] if index.stop is None else index.stop\n                index = list(range(start, stop, step))\n                new_indices.append(index)\n            else:\n                try:\n                    index = [i for i in index]\n                    new_indices.append(index)\n                except:\n                    raise Exception(f\"Indeks tidak valid: {index}\")\n\n        if len(self.shape) > len(indices):\n            new_indices.append(*self.indices[len(indices) :])\n\n        new_shape = [len(index) for index in new_indices]\n        x = NDArray()\n        x.data = self.data\n        x.strides = self.strides\n        x.shape = new_shape\n        x.indices = new_indices\n        return x\n    \n    def __add__(self, other):\n        return add(self, other)\n    \n    def __sub__(self, other):\n        return subtract(self, other)\n    \n    def __mul__(self, other):\n        return multiply(self, other)\n    \n    def __truediv__(self, other):\n        return divide(self, other)\nDaftar lengkap operator yang dapat di-overload dapat dilihat di dokumentasi python1\nMenggunakannya cukup sebagai berikut:\n\nx = ndarray_from_list([1, 2, 3], 3)\ny = ndarray_from_list([1, 2, 3], 3, 1)\n\nprint_ndarray(x)\nprint_ndarray(y)\n\nz = x + y  # menimpa operator + dengan fungsi add\nprint_ndarray(z)\n\nz = x - y  # menimpa operator - dengan fungsi subtract\nprint_ndarray(z)\n\nz = x * y  # menimpa operator * dengan fungsi multiply\nprint_ndarray(z)\n\nz = x / y  # menimpa operator / dengan fungsi divide\nprint_ndarray(z)\n\narray([1., 2., 3.])\narray([[1.],\n       [2.],\n       [3.]])\narray([[2., 3., 4.],\n       [3., 4., 5.],\n       [4., 5., 6.]])\narray([[ 0.,  1.,  2.],\n       [-1.,  0.,  1.],\n       [-2., -1.,  0.]])\narray([[1., 2., 3.],\n       [2., 4., 6.],\n       [3., 6., 9.]])\narray([[1.        , 2.        , 3.        ],\n       [0.5       , 1.        , 1.5       ],\n       [0.33333333, 0.66666667, 1.        ]])\n\n\nDalam komputasi saintifik, notasi ini akan lebih singkat dan mudah dibaca daripada memanggil fungsi secara berantai.\nPembaca dapat bereksplorasi sendiri untuk mengimplementasikan fungsi binary lainnya."
  },
  {
    "objectID": "utilitas.html",
    "href": "utilitas.html",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "",
    "text": "Reduce berfungsi untuk mereduksi dimensi suatu ndarray sebanyak 1 dengan cara menerapkan fungsi universal pada suatu dimensi yang direduksi tersebut1. Perhatikan potongan kode di bawah ini:\n\nn = np.multiply.reduce([2,3,5])\nprint(n)\n\n30\n\n\nKode di atas mereduksi dimensi array dari 1 (vektor) menjadi dimensi 0 (skalar) dengan cara mengalikan semua elemen array tersebut. Tidak hanya perkalian, kita bisa menggunakan fungsi binary lain, seperti penjumlahan, pengurangan, dll.\nKita dapat mengimplementasikan fungsi reduce versi kita sendiri.\ndef reduce_at_dim(arr, dim, func, keep_dim=False):\n    indices = [list(range(n)) for n in arr.shape]\n    indices[dim] = 0\n    result = arr[indices].as_list()\n\n    for i in range(1, arr.shape[dim]):\n        indices[dim] = i\n        arr_data = arr[indices].as_list()\n        for j in range(len(result)):\n            result[j] = func(result[j], arr_data[j])\n    new_shape = list(arr.shape)\n    new_shape[dim] = 1\n\n    result_arr = ndarray_from_list(result, *new_shape)\n\n    # # TODO: squeeze\n    return result_arr\n\n\n\nx = ndarray_from_list([1, 2, 3, 4], 2, 2)\n\nprint(\"Input:\")\nprint_ndarray(x)\nprint(\"\\nSum by axis 0:\")\nprint_ndarray(reduce_at_dim(x, 0, lambda x, y: x + y))\nprint(\"\\nSum by axis 1:\")\nprint_ndarray(reduce_at_dim(x, 1, lambda x, y: x + y))\n\nInput:\narray([[1., 2.],\n       [3., 4.]])\n\nSum by axis 0:\narray([[4., 6.]])\n\nSum by axis 1:\narray([[3.],\n       [7.]])\n\n\n\n\n\n\nx = ndarray_from_list(\n    [2, 1,\n     1, 4],\n     \n     2, 2\n)\n\nprint(\"Input:\")\nprint_ndarray(x)\nprint(\"\\nMax by axis 0:\")\nprint_ndarray(reduce_at_dim(x, 0, max))\nprint(\"\\nMax by axis 1:\")\nprint_ndarray(reduce_at_dim(x, 1, max))\n\nInput:\narray([[2., 1.],\n       [1., 4.]])\n\nMax by axis 0:\narray([[2., 4.]])\n\nMax by axis 1:\narray([[2.],\n       [4.]])"
  },
  {
    "objectID": "utilitas.html#rata-rata",
    "href": "utilitas.html#rata-rata",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Rata-rata",
    "text": "Rata-rata"
  },
  {
    "objectID": "utilitas.html#variansi-dan-standar-deviasi",
    "href": "utilitas.html#variansi-dan-standar-deviasi",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Variansi dan standar deviasi",
    "text": "Variansi dan standar deviasi"
  },
  {
    "objectID": "utilitas.html#transposisi",
    "href": "utilitas.html#transposisi",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Transposisi",
    "text": "Transposisi\ndef transpose(arr):\n    arr.strides = arr.strides[::-1]\n    arr.shape = arr.shape[::-1]\n    arr.rebuild_index()\n    return arr"
  },
  {
    "objectID": "utilitas.html#perkalian-matriks",
    "href": "utilitas.html#perkalian-matriks",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Perkalian matriks",
    "text": "Perkalian matriks\nPerkalian matriks banyak digunakan di berbagai disiplin ilmu yang melibatkan komputasi, termasuk di ranah machine learning.\n...\n\ndef matmul(arr1, arr2):\n    if len(arr1.shape) != 2 and len(arr2.shape) != 2:\n        raise Exception(\"Fungsi ini hanya bisa digunakan untuk ndarray berdimensi 2\")\n\n    if arr1.shape[1] != arr2.shape[0]:\n        raise Exception(\n            f\"Tidak bisa mengalikan ndarray berbentuk {arr1.shape} dan {arr2.shape}\"\n        )\n\n    result_data = []\n    for row in range(arr1.shape[0]):\n        for col in range(arr2.shape[1]):\n            vec1 = arr1[row]\n            vec2 = transpose(arr2[:, col])\n            dot = sum(multiply(vec1, vec2).as_list())\n            result_data.append(dot)\n    return ndarray_from_list(result_data, arr1.shape[0], arr2.shape[1])\n\nx = ndarray_from_list([1, 2, 3, 4, 5, 6], 3, 2)\ny = ndarray_from_list([1, 1, 1, 1, 1, 1], 2, 3)\nres = matmul(x, y)\nprint_ndarray(res)\n\narray([[ 3.,  3.,  3.],\n       [ 7.,  7.,  7.],\n       [11., 11., 11.]])\n\n\n\n\n\n\n\n\nCatatan\n\n\n\nPerkalian matriks adalah permasalahan yang sudah cukup lama dipelajari. Ada satu umum yang digunakan banyak ndarray dalam melakukan perkalian matriks, yaitu (BLAS). Tidak bisa dipungkiri perkalian matriks di buku ini naif dan lambat (selain karena python sendiri bahasa terinterpretasi dan lambat)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "",
    "text": "Halaman muka"
  },
  {
    "objectID": "supervised_learning_1.html",
    "href": "supervised_learning_1.html",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "",
    "text": "Dataset untuk supervised learning dapat direpresentasikan sebagai himpunan pasangan vektor fitur \\left\\{ (\\mathbf{x}_i, y_i) \\right\\}, dimana y_i adalah label dari data ke-i dan x_{i,j} adalah fitur ke-j pada \\mathbf{x}_i."
  },
  {
    "objectID": "supervised_learning_1.html#ordinary-least-squares-ols",
    "href": "supervised_learning_1.html#ordinary-least-squares-ols",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "Ordinary least squares (OLS)",
    "text": "Ordinary least squares (OLS)\nKita dapat merepresentasikan semua sampel dalam bentuk matriks \\mathbf{X} \\in \\mathbb{R}^{m \\times n}, di mana baris ke-i mewakili vektor feature \\mathbf{x}_i. Persamaan dapat ditulis ulang dengan lebih ringkas sebagai berikut.\n\nE(f;\\pmb{\\beta}) = \\lVert \\mathbf{X}\\pmb{\\beta} - \\mathbf{y} \\rVert^2\n% \\label{eq:mse_matrix_form}\n\nDengan substitusikan ruas kanan persamaan ke persamaan , dan menyamakan hasil turunan dengan 0, kita memperoleh nilai optimal dari parameter \\pmb{\\beta} sebagai berikut.\n\n\\begin{align}\n    \\frac{d}{d\\pmb{\\beta}} \\cdot E(f;\\pmb{\\beta}) &= 2\\mathbf{X}^\\top(\\mathbf{X}\\pmb{\\beta}-\\mathbf{y})\\\\\n    0 &=2(\\mathbf{X}^\\top\\mathbf{X})\\pmb{\\beta}-2\\mathbf{X}^\\top \\mathbf{y}\\\\\n    (\\mathbf{X}^\\top\\mathbf{X})\\pmb{\\beta} &= \\mathbf{X}^\\top \\mathbf{y}\\\\\n    \\widehat{\\pmb{\\beta}} &=(\\mathbf{X}^\\top\\mathbf{X})^{-1}\\mathbf{X}^\\top\n    \\mathbf{y}.\n\\end{align}\n% \\label{eq:beta_est}\n\nBerikut ini adalah contoh implementasi OLS pada python.\nfrom sklearn.datasets import make_regression\n\nX, y = make_regression(n_samples=100, n_targets=1)\n\n# Tambah variabel intercept\nX = hstack([ones((X.shape[0], 1)), X])\n\nbeta = inv(X.T @ X) @ X.T @ y\n\ny_hat = X @ beta\nMasalah utama dari OLS adalah operasi inverse yang mahal. Perhatikan persamaan , di mana kita perlu menghitung (\\mathbf{X}^\\top\\mathbf{X})^\\dagger. Andaikan ada 10000 sampel, maka pada akhirnya kita perlu menghitung invers dari suatu matriks berukuran 10000 \\times 10000. Selain itu, diketahui bahwa algoritma invers memiliki kompleksitas O(n^3). Kita membutuhkan alat yang lebih tepat, terlebih jika sudah berurusan dengan big data."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "",
    "text": "In summary, this book has no content whatsoever. \\vecx"
  },
  {
    "objectID": "autograd.html",
    "href": "autograd.html",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "",
    "text": "Operasi pada ndarray sebagai komputasi graf\n\n\nAutograd dengan mode backward"
  },
  {
    "objectID": "pendahuluan.html",
    "href": "pendahuluan.html",
    "title": "ML From Scratch: Implementasi di balik layar",
    "section": "",
    "text": "References\n\nGrus, Joel. 2019. Data Science from Scratch: First Principles with Python. O’Reilly Media."
  }
]